/**
 * @file src/program/game/dialogue/Dialogue.hpp
 * @author Adam 'Adanos' GÄ…sior
 * Used library: SFML
 */

#ifndef DIALOGUE_HPP
#define DIALOGUE_HPP

namespace rr
{
    
    class Branch
    {
    private: Branch* m_left  = nullptr;
             Branch* m_right = nullptr;
    
    public:  ////////////////////////////////////////////////////////////////////////
             /// \brief Virtual destructor.
             ////////////////////////////////////////////////////////////////////////
     virtual ~Branch() { if (m_left != nullptr) delete m_left; if (m_right != nullptr) delete m_right; }

             ////////////////////////////////////////////////////////////////////////
             /// \brief Sets the left link.
             ////////////////////////////////////////////////////////////////////////
             void setLeft(Branch* b) { m_left = b; }

             ////////////////////////////////////////////////////////////////////////
             /// \brief Sets the right link.
             ////////////////////////////////////////////////////////////////////////
             void setRight(Branch* b) { m_right = b; }

             ////////////////////////////////////////////////////////////////////////
             /// \brief Returns the left link.
             ////////////////////////////////////////////////////////////////////////
             Branch* getLeft() const { return m_left; }

             ////////////////////////////////////////////////////////////////////////
             /// \brief Returns the right link.
             ////////////////////////////////////////////////////////////////////////
             Branch* getRight() const { return m_right; }
    };

    class Sentence : public Branch
    {
    public:  enum Speaker
             {
                 PLAYER,
                 _NPC
             };

             ////////////////////////////////////////////////////////////////////////
             /// \brief Regular constructor.
             ////////////////////////////////////////////////////////////////////////
             Sentence(Speaker, sf::String);

             ////////////////////////////////////////////////////////////////////////
             /// \brief Returns the speaker of the sentence.
             ////////////////////////////////////////////////////////////////////////
             Speaker getSpeaker() const { return m_speaker; }

             ////////////////////////////////////////////////////////////////////////
             /// \brief Returns the sentence's string.
             ////////////////////////////////////////////////////////////////////////
             sf::String getSentence() const { return m_sentence; }

    private: Speaker    m_speaker;
             sf::String m_sentence;
    };

    class Answers : public Branch
    {
    private: std::vector<Sentence*> m_answers;

    public:  ////////////////////////////////////////////////////////////////////////
             /// \brief Adds an answer to the list.
             ////////////////////////////////////////////////////////////////////////
             void addAnswer(Sentence* s) { m_answers.push_back(s); }

             ////////////////////////////////////////////////////////////////////////
             /// \brief Removes an answer from the list.
             ///
             /// \return true if an answer was removed, otherwise false
             ////////////////////////////////////////////////////////////////////////
             bool removeAnswer(Sentence*);

             ////////////////////////////////////////////////////////////////////////
             /// \brief Removes an answer from the list.
             ///
             /// \return true if an answer was removed, otherwise false
             ////////////////////////////////////////////////////////////////////////
             bool removeAnswer(sf::String);

             ////////////////////////////////////////////////////////////////////////
             /// \brief Returns the list of answers.
             ////////////////////////////////////////////////////////////////////////
             std::vector<Sentence*> getAnswers() const { return m_answers; }

             ////////////////////////////////////////////////////////////////////////
             /// \brief Finds an answer that equals the given string.
             ///
             /// \return a Sentence branch if the answer is found, nullptr if not.
             ////////////////////////////////////////////////////////////////////////
             Sentence* find(sf::String) const;
    };

    class DialogueTree
    {
    public:  ////////////////////////////////////////////////////////////////////////
             /// \brief Regular constructor.
             ////////////////////////////////////////////////////////////////////////
             DialogueTree();

             ////////////////////////////////////////////////////////////////////////
             /// \brief Destructor.
             ////////////////////////////////////////////////////////////////////////
            ~DialogueTree() { if (m_root != nullptr) delete m_root; }

             ////////////////////////////////////////////////////////////////////////
             /// \brief Assigns the tree.
             ////////////////////////////////////////////////////////////////////////
             void setTree(Branch*, bool permanent = false);

             ////////////////////////////////////////////////////////////////////////
             /// \brief Sets the pointer to the current branch to its left branch.
             ////////////////////////////////////////////////////////////////////////
             void goLeft() { m_current = m_current->getLeft(); }

             ////////////////////////////////////////////////////////////////////////
             /// \brief Sets the pointer to the current branch to its right branch.
             ////////////////////////////////////////////////////////////////////////
             void goRight() { m_current = m_current->getRight(); }

             ////////////////////////////////////////////////////////////////////////
             /// \brief Returns the current step of the dialogue.
             ////////////////////////////////////////////////////////////////////////
             Branch* getCurrentBranch() { return m_current; }

             ////////////////////////////////////////////////////////////////////////
             /// \brief Sets the pointer to the current step to the initial one.
             ////////////////////////////////////////////////////////////////////////
             void reset() { m_current = m_root; }
    
    private: Branch* m_current;
             Branch* m_root;
    };

}

#endif // DIALOGUE_HPP
